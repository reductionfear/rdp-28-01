name: Infinite RDP Session

on:
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Session identifier (auto-generated for chains)'
        required: false
        default: ''
      chain_count:
        description: 'Chain iteration counter'
        required: false
        default: '0'
  repository_dispatch:
    types: [chain-rdp]

env:
  SESSION_TIMEOUT_MINUTES: 330  # 5.5 hours (GitHub limit is 6h)
  CHAIN_BUFFER_MINUTES: 15     # Start new session 15 min before timeout
  PERSIST_DIR: C:\rdp-persist  # Directory for persistent data

jobs:
  rdp-session:
    runs-on: windows-latest
    timeout-minutes: 350

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate session info
        id: session
        shell: pwsh
        run: |
          $sessionId = "${{ github.event.inputs.session_id }}"
          if ([string]::IsNullOrEmpty($sessionId)) {
            $sessionId = [guid]::NewGuid().ToString().Substring(0,8)
          }
          
          # Handle chain count safely
          $chainCountInput = "${{ github.event.inputs.chain_count }}"
          if ([string]::IsNullOrEmpty($chainCountInput)) {
            $chainCount = 0
          } else {
            $chainCount = [int]$chainCountInput
          }
          
          # Check if this is a repository_dispatch event
          if ("${{ github.event_name }}" -eq "repository_dispatch") {
            $payloadCount = "${{ github.event.client_payload.chain_count }}"
            if (-not [string]::IsNullOrEmpty($payloadCount)) {
              $chainCount = [int]$payloadCount
            }
          }
          
          echo "SESSION_ID=$sessionId" >> $env:GITHUB_OUTPUT
          echo "CHAIN_COUNT=$chainCount" >> $env:GITHUB_OUTPUT
          echo "START_TIME=$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_OUTPUT
          
          Write-Host "Session ID: $sessionId"
          Write-Host "Chain iteration: $chainCount"

      # ========== RESTORE PERSISTED DATA ==========
      - name: Download persisted data
        if: ${{ github.event.inputs.chain_count != '0' || github.event_name == 'repository_dispatch' }}
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: rdp-session.yml
          name: rdp-session-data-${{ steps.session.outputs.SESSION_ID }}
          path: ${{ env.PERSIST_DIR }}
          if_no_artifact_found: warn
        continue-on-error: true

      - name: Restore user data
        shell: pwsh
        run: |
          $persistDir = "${{ env.PERSIST_DIR }}"
          
          # Get rdpuser's actual profile path
          # First check registry for the real profile path
          $rdpUserHome = "C:\Users\rdpuser"
          $username = "rdpuser"
          
          try {
            $userSid = (Get-LocalUser -Name $username -ErrorAction SilentlyContinue).SID.Value
            if ($userSid) {
              $profileKey = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\$userSid"
              if (Test-Path $profileKey) {
                $regProfile = (Get-ItemProperty -Path $profileKey -Name ProfileImagePath -ErrorAction SilentlyContinue).ProfileImagePath
                if ($regProfile) {
                  $rdpUserHome = $regProfile
                  Write-Host "Using registry profile path: $rdpUserHome"
                }
              }
            }
          } catch {
            Write-Host "Could not check registry, using default path"
          }
          
          Write-Host "Restoring data to rdpuser profile: $rdpUserHome"
          
          # Create rdpuser profile directory if it doesn't exist yet
          New-Item -ItemType Directory -Path $rdpUserHome -Force | Out-Null
          
          # Find the zip file to restore (prefer userdata.zip, fallback to newest timestamped)
          $zipToRestore = $null
          if (Test-Path "$persistDir\userdata.zip") {
            $zipToRestore = "$persistDir\userdata.zip"
          } else {
            # Look for timestamped zips
            $zips = Get-ChildItem -Path $persistDir -Filter "userdata*.zip" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
            if ($zips.Count -gt 0) {
              $zipToRestore = $zips[0].FullName
              Write-Host "Using timestamped zip: $($zips[0].Name)"
            }
          }
          
          if ($zipToRestore -and (Test-Path $zipToRestore)) {
            Write-Host "Restoring persisted user data from: $zipToRestore"
            
            # Read the OLD userprofile path from previous session
            $oldUserHome = ""
            if (Test-Path "$persistDir\userprofile.txt") {
              $oldUserHome = Get-Content "$persistDir\userprofile.txt" -Raw
              $oldUserHome = $oldUserHome.Trim()
              Write-Host "Previous session USERPROFILE was: $oldUserHome"
            }
            
            # Extract user data to rdpuser's USERPROFILE
            Expand-Archive -Path $zipToRestore -DestinationPath $rdpUserHome -Force
            
            Write-Host "User data restored to $rdpUserHome"
            
            # Patch config files to replace old/runner paths with rdpuser path
            # Always patch common runner usernames, not just the saved oldUserHome
            $pathsToReplace = @(
              "C:\Users\runneradmin",
              "C:\Users\runner", 
              "C:\Users\ContainerAdministrator"
            )
            
            # Also add oldUserHome if it's different from rdpUserHome
            if ($oldUserHome -and ($oldUserHome -ne $rdpUserHome) -and ($pathsToReplace -notcontains $oldUserHome)) {
              $pathsToReplace += $oldUserHome
            }
            
            Write-Host "Will patch these paths to $rdpUserHome :"
            $pathsToReplace | ForEach-Object { Write-Host "  - $_" }
            
            # Files that may contain hardcoded paths
            $configFiles = @(
              "$rdpUserHome\.clawdbot\clawdbot.json",
              "$rdpUserHome\.clawdbot\agents\main\agent\auth-profiles.json",
              "$rdpUserHome\.clawdbot\agents\main\agent.json",
              "$rdpUserHome\.npmrc",
              "$rdpUserHome\.gitconfig"
            )
            
            foreach ($file in $configFiles) {
              if (Test-Path $file) {
                $content = Get-Content $file -Raw -ErrorAction SilentlyContinue
                if ($content) {
                  $patched = $false
                  
                  foreach ($oldPath in $pathsToReplace) {
                    if ($content.Contains($oldPath) -or $content.Contains(($oldPath -replace '\\', '/')) -or $content.Contains(($oldPath -replace '\\', '\\\\'))) {
                      # Replace backslash, forward slash, and escaped versions
                      $oldPathBackslash = $oldPath
                      $newPathBackslash = $rdpUserHome
                      $oldPathForward = $oldPath -replace '\\', '/'
                      $newPathForward = $rdpUserHome -replace '\\', '/'
                      $oldPathEscaped = $oldPath -replace '\\', '\\\\'
                      $newPathEscaped = $rdpUserHome -replace '\\', '\\\\'
                      
                      $content = $content -replace [regex]::Escape($oldPathEscaped), $newPathEscaped
                      $content = $content -replace [regex]::Escape($oldPathBackslash), $newPathBackslash
                      $content = $content -replace [regex]::Escape($oldPathForward), $newPathForward
                      
                      $patched = $true
                      Write-Host "  Patched $oldPath in: $file"
                    }
                  }
                  
                  if ($patched) {
                    Set-Content -Path $file -Value $content -NoNewline
                  }
                }
              }
            }
            
            # Set proper ownership for rdpuser
            Write-Host "Setting ownership for rdpuser..."
            icacls $rdpUserHome /grant "rdpuser:(OI)(CI)F" /T /Q 2>$null; $true
            
            # List what was restored
            Write-Host "Restored contents:"
            Get-ChildItem -Path $rdpUserHome -Force | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "No persisted data found (first session or artifact expired)"
          }

      # ========== TAILSCALE SETUP ==========
      - name: Install Tailscale
        shell: pwsh
        run: |
          Write-Host "Installing Tailscale..."
          
          # Download Tailscale MSI
          $url = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installer = "$env:TEMP\tailscale-setup.msi"
          
          Invoke-WebRequest -Uri $url -OutFile $installer -UseBasicParsing
          
          # Silent install
          Start-Process msiexec.exe -ArgumentList "/i", $installer, "/quiet", "/norestart" -Wait
          
          # Add to PATH
          $env:PATH += ";C:\Program Files\Tailscale"
          echo "C:\Program Files\Tailscale" >> $env:GITHUB_PATH
          
          Write-Host "Tailscale installed successfully"

      - name: Connect to Tailscale
        shell: pwsh
        env:
          TAILSCALE_AUTHKEY: ${{ secrets.TAILSCALE_AUTHKEY }}
        run: |
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $hostname = "gh-rdp-$sessionId"
          
          Write-Host "Connecting to Tailscale as: $hostname"
          
          # Start Tailscale service
          Start-Service -Name "Tailscale" -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
          
          # Authenticate with Tailscale
          # Note: Tags are embedded in the auth key, not passed here
          # If you need to override, use: --advertise-tags=tag:github-runner
          & "C:\Program Files\Tailscale\tailscale.exe" up `
            --authkey="$env:TAILSCALE_AUTHKEY" `
            --hostname="$hostname" `
            --accept-routes `
            --accept-dns
          
          Start-Sleep -Seconds 10
          
          # Get and display Tailscale IP
          $status = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          Write-Host "=========================================="
          Write-Host "TAILSCALE IP: $status"
          Write-Host "HOSTNAME: $hostname"
          Write-Host "=========================================="
          
          # Save IP for later use
          echo "TAILSCALE_IP=$status" >> $env:GITHUB_OUTPUT

      # ========== RDP SETUP ==========
      - name: Configure RDP Access
        shell: pwsh
        run: |
          Write-Host "Configuring RDP access..."
          
          # Enable RDP
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
          
          # Configure firewall for RDP
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          
          # Allow RDP through Windows Firewall
          netsh advfirewall firewall add rule name="RDP-Tailscale" dir=in action=allow protocol=tcp localport=3389
          
          # Set Network Level Authentication (optional, more secure)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
          
          Write-Host "RDP configured successfully"

      - name: Create RDP User
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          
          if ([string]::IsNullOrEmpty($password)) {
            # Generate random password if not provided
            $password = -join ((65..90) + (97..122) + (48..57) + (33,35,36,37,38,42) | Get-Random -Count 16 | ForEach-Object {[char]$_})
            Write-Host "Generated password: $password"
          }
          
          # Create user
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          
          try {
            New-LocalUser -Name $username -Password $securePassword -FullName "RDP User" -Description "GitHub Actions RDP User" -PasswordNeverExpires
          } catch {
            # User might already exist, update password
            Set-LocalUser -Name $username -Password $securePassword
          }
          
          # Add to necessary groups
          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue
          
          Write-Host "=========================================="
          Write-Host "RDP CREDENTIALS"
          Write-Host "Username: $username"
          Write-Host "Password: (check secrets or generated above)"
          Write-Host "=========================================="

      - name: Initialize rdpuser profile
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          $rdpUserHome = "C:\Users\rdpuser"
          
          Write-Host "Initializing user profile for rdpuser..."
          
          # Force Windows to create the user profile by running a process as that user
          # This ensures the profile is properly initialized before RDP login
          
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
          
          # Create a simple script that initializes the profile
          $initScript = @"
          # This runs as rdpuser to initialize the profile
          Write-Host "Profile initialized for: `$env:USERNAME"
          Write-Host "USERPROFILE: `$env:USERPROFILE"
          
          # Create standard directories
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\Documents" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\Desktop" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\Downloads" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\projects" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\.clawdbot" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\.npm-global" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$env:USERPROFILE\.local\bin" -Force | Out-Null
          
          # Output the actual profile path
          "`$env:USERPROFILE" | Out-File -FilePath "C:\rdp-persist\actual-userprofile.txt" -Encoding UTF8 -NoNewline
          "@
          
          $initScriptPath = "$env:TEMP\init-profile.ps1"
          $initScript | Out-File -FilePath $initScriptPath -Encoding UTF8
          
          # Create persist dir if not exists
          New-Item -ItemType Directory -Path "C:\rdp-persist" -Force | Out-Null
          
          # Run a process as rdpuser to initialize the profile
          # Using Start-Process with credentials creates the profile
          try {
            $processInfo = New-Object System.Diagnostics.ProcessStartInfo
            $processInfo.FileName = "powershell.exe"
            $processInfo.Arguments = "-ExecutionPolicy Bypass -File `"$initScriptPath`""
            $processInfo.UseShellExecute = $false
            $processInfo.LoadUserProfile = $true
            $processInfo.UserName = $username
            $processInfo.Password = $securePassword
            $processInfo.Domain = $env:COMPUTERNAME
            $processInfo.RedirectStandardOutput = $true
            $processInfo.RedirectStandardError = $true
            
            $process = [System.Diagnostics.Process]::Start($processInfo)
            $output = $process.StandardOutput.ReadToEnd()
            $errors = $process.StandardError.ReadToEnd()
            $process.WaitForExit(60000)  # 60 second timeout
            
            Write-Host "Profile init output: $output"
            if ($errors) { Write-Host "Profile init errors: $errors" }
            
          } catch {
            Write-Host "Could not run as rdpuser directly: $_"
            Write-Host "Trying alternative method..."
            
            # Alternative: use runas or psexec-style approach
            # Create profile directory structure manually as admin
            New-Item -ItemType Directory -Path $rdpUserHome -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\Documents" -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\Desktop" -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\Downloads" -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Local" -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Roaming" -Force | Out-Null
            New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Local\Temp" -Force | Out-Null
            
            # Set the profile path in registry to ensure Windows uses this path
            $profileList = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
            $userSid = (Get-LocalUser -Name $username).SID.Value
            
            if ($userSid) {
              $profileKey = "$profileList\$userSid"
              if (-not (Test-Path $profileKey)) {
                New-Item -Path $profileKey -Force | Out-Null
              }
              Set-ItemProperty -Path $profileKey -Name "ProfileImagePath" -Value $rdpUserHome -Type ExpandString
              Set-ItemProperty -Path $profileKey -Name "State" -Value 0 -Type DWord
              Set-ItemProperty -Path $profileKey -Name "RefCount" -Value 0 -Type DWord
              
              Write-Host "Set profile path in registry: $rdpUserHome"
            }
          }
          
          # Verify what profile path will be used
          if (Test-Path "C:\rdp-persist\actual-userprofile.txt") {
            $actualProfile = Get-Content "C:\rdp-persist\actual-userprofile.txt" -Raw
            Write-Host "Actual rdpuser profile path: $actualProfile"
          }
          
          # Grant full permissions to rdpuser on the profile directory  
          icacls $rdpUserHome /grant "rdpuser:(OI)(CI)F" /T /Q 2>$null; $true
          
          # List what we created
          Write-Host "Profile directories:"
          Get-ChildItem -Path "C:\Users" -Directory | ForEach-Object { 
            Write-Host "  $($_.Name) - $($_.FullName)" 
          }
          
          Write-Host "Profile initialization complete"

      - name: Configure environment for rdpuser
        shell: pwsh
        run: |
          # Get the actual rdpuser profile path (may differ from C:\Users\rdpuser)
          $rdpUserHome = "C:\Users\rdpuser"
          
          # Check if we have the actual profile path from initialization
          if (Test-Path "C:\rdp-persist\actual-userprofile.txt") {
            $actualProfile = (Get-Content "C:\rdp-persist\actual-userprofile.txt" -Raw).Trim()
            if ($actualProfile -and (Test-Path $actualProfile)) {
              $rdpUserHome = $actualProfile
              Write-Host "Using actual profile path: $rdpUserHome"
            }
          }
          
          # Also check registry for the profile path
          $username = "rdpuser"
          try {
            $userSid = (Get-LocalUser -Name $username -ErrorAction SilentlyContinue).SID.Value
            if ($userSid) {
              $profileKey = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\$userSid"
              if (Test-Path $profileKey) {
                $regProfile = (Get-ItemProperty -Path $profileKey -Name ProfileImagePath -ErrorAction SilentlyContinue).ProfileImagePath
                if ($regProfile -and (Test-Path $regProfile)) {
                  $rdpUserHome = $regProfile
                  Write-Host "Using registry profile path: $rdpUserHome"
                }
              }
            }
          } catch {
            Write-Host "Could not check registry, using default path"
          }
          
          Write-Host "Configuring environment for rdpuser: $rdpUserHome"
          
          # Save the profile path for other steps
          $rdpUserHome | Out-File -FilePath "C:\rdp-persist\rdpuser-home.txt" -Encoding UTF8 -NoNewline
          
          # Create directories for rdpuser
          New-Item -ItemType Directory -Path "$rdpUserHome\projects" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.clawdbot" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.npm-global" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\scoop" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Roaming" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Local" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.local\bin" -Force | Out-Null
          
          # Set machine-wide environment variables pointing to rdpuser's profile
          [Environment]::SetEnvironmentVariable("CLAWDBOT_STATE_DIR", "$rdpUserHome\.clawdbot", "Machine")
          [Environment]::SetEnvironmentVariable("CLAWDBOT_WORKSPACE", "$rdpUserHome\projects", "Machine")
          [Environment]::SetEnvironmentVariable("SCOOP", "$rdpUserHome\scoop", "Machine")
          
          # Fix NPM prefix - Chocolatey sets NPM_CONFIG_PREFIX which overrides npm config
          [Environment]::SetEnvironmentVariable("NPM_CONFIG_PREFIX", "$rdpUserHome\.npm-global", "Machine")
          
          # Update PATH with rdpuser's directories
          $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
          $newPaths = @(
            "$rdpUserHome\.npm-global",
            "$rdpUserHome\scoop\shims",
            "$rdpUserHome\.local\bin"
          )
          foreach ($p in $newPaths) {
            if ($currentPath -notlike "*$p*") {
              $currentPath = "$p;$currentPath"
            }
          }
          [Environment]::SetEnvironmentVariable("Path", $currentPath, "Machine")
          
          # Set ownership for rdpuser
          icacls $rdpUserHome /grant "rdpuser:(OI)(CI)F" /T /Q 2>$null; $true
          
          Write-Host "Environment configured for rdpuser:"
          Write-Host "  Profile path: $rdpUserHome"
          Write-Host "  CLAWDBOT_STATE_DIR = $rdpUserHome\.clawdbot"
          Write-Host "  CLAWDBOT_WORKSPACE = $rdpUserHome\projects"
          Write-Host "  SCOOP = $rdpUserHome\scoop"
          Write-Host "  NPM_CONFIG_PREFIX = $rdpUserHome\.npm-global"
          Write-Host "  PATH includes npm-global, scoop shims, and .local/bin"

      - name: Install Development Tools
        shell: pwsh
        run: |
          Write-Host "Installing development tools..."
          
          # Install Chocolatey
          Set-ExecutionPolicy Bypass -Scope Process -Force
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
          iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
          
          # Refresh PATH
          $env:PATH = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          
          # Install common dev tools
          choco install -y git vscode nodejs-lts python3 7zip --no-progress
          
          # Refresh PATH again after nodejs install
          $env:PATH = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          
          Write-Host "Development tools installed"

      - name: Configure NPM for rdpuser global installs
        shell: pwsh
        run: |
          # Get rdpuser's actual profile path
          $rdpUserHome = "C:\Users\rdpuser"
          if (Test-Path "C:\rdp-persist\rdpuser-home.txt") {
            $savedPath = (Get-Content "C:\rdp-persist\rdpuser-home.txt" -Raw).Trim()
            if ($savedPath) { $rdpUserHome = $savedPath }
          }
          
          $npmGlobalDir = "$rdpUserHome\.npm-global"
          
          Write-Host "Configuring NPM for rdpuser: $rdpUserHome"
          
          # Create directories
          New-Item -ItemType Directory -Path $npmGlobalDir -Force | Out-Null
          
          # Set env var for this session (for any npm calls in workflow)
          $env:NPM_CONFIG_PREFIX = $npmGlobalDir
          
          # Add npm global bin to PATH for this session
          $env:PATH = "$npmGlobalDir;$env:PATH"
          
          # Verify npm is working
          Write-Host "NPM version: $(npm --version)"
          Write-Host "NPM prefix: $(npm config get prefix)"
          Write-Host "NPM configured to install global packages to: $npmGlobalDir"

      - name: Install Scoop for rdpuser
        shell: pwsh
        run: |
          # Get rdpuser's actual profile path
          $rdpUserHome = "C:\Users\rdpuser"
          if (Test-Path "C:\rdp-persist\rdpuser-home.txt") {
            $savedPath = (Get-Content "C:\rdp-persist\rdpuser-home.txt" -Raw).Trim()
            if ($savedPath) { $rdpUserHome = $savedPath }
          }
          
          $scoopDir = "$rdpUserHome\scoop"
          
          Write-Host "Installing Scoop to: $scoopDir"
          
          # Check if Scoop already exists (restored from previous session)
          if (Test-Path "$scoopDir\shims\scoop.ps1") {
            Write-Host "Scoop already installed (restored from previous session)"
            $env:SCOOP = $scoopDir
            $env:PATH = "$scoopDir\shims;$env:PATH"
          } else {
            Write-Host "Installing Scoop..."
            
            # Set Scoop to install in rdpuser's directory
            $env:SCOOP = $scoopDir
            
            # Install Scoop
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
            Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression
            
            Write-Host "Scoop installed successfully"
          }
          
          # Install common tools that skills need
          Write-Host "Installing common tools via Scoop..."
          scoop install git go ffmpeg yt-dlp --no-cache 2>$null
          
          # Set ownership for rdpuser
          icacls $scoopDir /grant "rdpuser:(OI)(CI)F" /T /Q 2>$null; $true
          
          Write-Host "Scoop ready! Install apps with: scoop install <app>"

      - name: Install Custom Apps
        shell: pwsh
        run: |
          Write-Host "Checking for custom applications..."
          
          # Get rdpuser's actual profile path
          $rdpUserHome = "C:\Users\rdpuser"
          if (Test-Path "C:\rdp-persist\rdpuser-home.txt") {
            $savedPath = (Get-Content "C:\rdp-persist\rdpuser-home.txt" -Raw).Trim()
            if ($savedPath) { $rdpUserHome = $savedPath }
          }
          
          $npmGlobalDir = "$rdpUserHome\.npm-global"
          $localBin = "$rdpUserHome\.local\bin"
          $scoopShims = "$rdpUserHome\scoop\shims"
          
          Write-Host "Using rdpuser profile: $rdpUserHome"
          
          # Ensure PATH includes all custom locations for this session
          $env:PATH = "$npmGlobalDir;$localBin;$scoopShims;$env:PATH"
          
          # ============================================================
          # CLAWDBOT - Check if already installed
          # ============================================================
          $clawdbotExists = $false
          
          if (Test-Path "$npmGlobalDir\clawdbot.cmd") { $clawdbotExists = $true }
          if (Test-Path "$npmGlobalDir\node_modules\clawdbot") { $clawdbotExists = $true }
          if (Test-Path "$localBin\clawdbot.cmd") { $clawdbotExists = $true }
          if (Get-Command clawdbot -ErrorAction SilentlyContinue) { $clawdbotExists = $true }
          
          if ($clawdbotExists) {
            Write-Host "=============================================="
            Write-Host "Clawdbot FOUND (restored from previous session)"
            Write-Host "=============================================="
            Write-Host "No reinstall needed - ready to use!"
          } else {
            Write-Host "=============================================="
            Write-Host "Clawdbot not installed yet"
            Write-Host "=============================================="
            Write-Host ""
            Write-Host "After connecting via RDP, run:"
            Write-Host "  npm install -g clawdbot"
            Write-Host ""
            Write-Host "It will persist across all future sessions!"
          }
          
          # ============================================================
          # SCOOP STATUS
          # ============================================================
          Write-Host ""
          Write-Host "Scoop package manager ready!"
          Write-Host "Install Windows apps with: scoop install <app>"
          Write-Host "All scoop apps persist across sessions!"
          Write-Host ""
          Write-Host "Example: scoop install ffmpeg yt-dlp go python"
          
          Write-Host ""
          Write-Host "Custom apps step complete"

      - name: Display Connection Info
        id: connection
        shell: pwsh
        run: |
          $tailscaleIp = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $chainCount = "${{ steps.session.outputs.CHAIN_COUNT }}"
          
          # Get rdpuser's actual profile path
          $rdpUserHome = "C:\Users\rdpuser"
          if (Test-Path "C:\rdp-persist\rdpuser-home.txt") {
            $savedPath = (Get-Content "C:\rdp-persist\rdpuser-home.txt" -Raw).Trim()
            if ($savedPath) { $rdpUserHome = $savedPath }
          }
          
          Write-Host ""
          Write-Host "=============================================="
          Write-Host "       RDP SESSION READY"
          Write-Host "=============================================="
          Write-Host ""
          Write-Host "Session ID:    $sessionId"
          Write-Host "Chain Count:   $chainCount"
          Write-Host "Tailscale IP:  $tailscaleIp"
          Write-Host "Hostname:      gh-rdp-$sessionId"
          Write-Host ""
          Write-Host "Connect via RDP:"
          Write-Host "  Address:  $tailscaleIp:3389"
          Write-Host "  -or-      gh-rdp-$sessionId:3389"
          Write-Host "  Username: rdpuser"
          Write-Host "  Password: (from RDP_PASSWORD secret)"
          Write-Host ""
          Write-Host "rdpuser profile path: $rdpUserHome"
          Write-Host ""
          Write-Host "Persistent directories (auto-saved from rdpuser):"
          Write-Host "  $rdpUserHome\projects"
          Write-Host "  $rdpUserHome\.clawdbot"
          Write-Host "  $rdpUserHome\.npm-global"
          Write-Host "  $rdpUserHome\scoop"
          Write-Host ""
          Write-Host "All data in rdpuser profile persists across sessions!"
          Write-Host "Session will auto-chain in ~${{ env.SESSION_TIMEOUT_MINUTES }} minutes"
          Write-Host "=============================================="

      # ========== AUTO-SAVE SCHEDULER ==========
      - name: Setup auto-save scheduled task
        shell: pwsh
        run: |
          $persistDir = "${{ env.PERSIST_DIR }}"
          
          # Get rdpuser's actual profile path
          $rdpUserHome = "C:\Users\rdpuser"
          
          # Check saved profile path first
          if (Test-Path "C:\rdp-persist\rdpuser-home.txt") {
            $savedPath = (Get-Content "C:\rdp-persist\rdpuser-home.txt" -Raw).Trim()
            if ($savedPath -and (Test-Path $savedPath)) {
              $rdpUserHome = $savedPath
            }
          }
          
          # Also check registry as backup
          $username = "rdpuser"
          try {
            $userSid = (Get-LocalUser -Name $username -ErrorAction SilentlyContinue).SID.Value
            if ($userSid) {
              $profileKey = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\$userSid"
              if (Test-Path $profileKey) {
                $regProfile = (Get-ItemProperty -Path $profileKey -Name ProfileImagePath -ErrorAction SilentlyContinue).ProfileImagePath
                if ($regProfile -and (Test-Path $regProfile)) {
                  $rdpUserHome = $regProfile
                }
              }
            }
          } catch { }
          
          Write-Host "Auto-save will save from rdpuser: $rdpUserHome"
          
          # Create persist directory
          New-Item -ItemType Directory -Path $persistDir -Force | Out-Null
          
          # Store rdpuser's USERPROFILE so next session can patch paths
          $rdpUserHome | Out-File -FilePath "$persistDir\userprofile.txt" -Encoding UTF8 -NoNewline
          Write-Host "Saved USERPROFILE path to $persistDir\userprofile.txt"
          
          # Create save script - saves rdpuser's data
          $saveScript = @"
          `$persistDir = "$persistDir"
          `$userHome = "$rdpUserHome"
          `$appData = "`$userHome\AppData"
          `$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          
          Write-Host "[`$timestamp] Auto-saving rdpuser data from `$userHome..."
          
          # Directories to persist (user files)
          `$dirsToSave = @(
            "`$userHome\projects",
            "`$userHome\Documents",
            "`$userHome\Desktop",
            "`$userHome\.ssh",
            "`$userHome\.gitconfig",
            "`$userHome\.vscode",
            "`$userHome\.local",           # local bin
            "`$userHome\.npm-global",      # NPM global packages (includes clawdbot!)
            "`$userHome\.npmrc",           # NPM config
            "`$userHome\scoop",            # Scoop + all scoop-installed apps!
            "`$userHome\.clawdbot",        # Clawdbot config directory
            "`$userHome\clawd",            # Clawdbot identity/memory docs
            "`$userHome\.config"           # Config directory
          )
          
          # AppData directories to persist (app settings)
          `$appDataToSave = @(
            "`$appData\Roaming\Code",           # VS Code settings
            "`$appData\Roaming\npm",            # NPM global packages/config
            "`$appData\Roaming\npm-cache",      # NPM cache
            "`$appData\Local\Programs",         # Some apps install here
            "`$appData\Roaming\clawdbot",       # Clawdbot settings
            "`$appData\Local\clawdbot",         # Clawdbot local data
            "`$appData\Local\pnpm",             # pnpm
            "`$appData\Local\pnpm-cache"        # pnpm cache
          )
          
          # Create temp directory for backup
          `$tempBackup = "`$env:TEMP\rdp-backup-`$timestamp"
          New-Item -ItemType Directory -Path `$tempBackup -Force | Out-Null
          New-Item -ItemType Directory -Path "`$tempBackup\AppData\Roaming" -Force | Out-Null
          New-Item -ItemType Directory -Path "`$tempBackup\AppData\Local" -Force | Out-Null
          
          # Save user directories
          foreach (`$dir in `$dirsToSave) {
            if (Test-Path `$dir) {
              `$name = Split-Path `$dir -Leaf
              Copy-Item -Path `$dir -Destination "`$tempBackup\`$name" -Recurse -Force -ErrorAction SilentlyContinue
              Write-Host "  Saved: `$name"
            }
          }
          
          # Save AppData directories
          foreach (`$dir in `$appDataToSave) {
            if (Test-Path `$dir) {
              `$relativePath = `$dir -replace [regex]::Escape("`$userHome\"), ""
              `$destPath = "`$tempBackup\`$relativePath"
              `$destParent = Split-Path `$destPath -Parent
              New-Item -ItemType Directory -Path `$destParent -Force -ErrorAction SilentlyContinue | Out-Null
              Copy-Item -Path `$dir -Destination `$destPath -Recurse -Force -ErrorAction SilentlyContinue
              Write-Host "  Saved: `$relativePath"
            }
          }
          
          # Create zip archive - use temp file to avoid lock issues
          if (Test-Path "`$tempBackup\*") {
            `$tempZip = "`$persistDir\userdata-`$timestamp.zip"
            `$finalZip = "`$persistDir\userdata.zip"
            
            # Create new zip with timestamp name
            Compress-Archive -Path "`$tempBackup\*" -DestinationPath `$tempZip -Force
            
            # Remove old zip if exists (with retries for file lock)
            if (Test-Path `$finalZip) {
              `$retries = 3
              while (`$retries -gt 0) {
                try {
                  Remove-Item -Path `$finalZip -Force -ErrorAction Stop
                  break
                } catch {
                  `$retries--
                  if (`$retries -gt 0) {
                    Write-Host "  Zip locked, retrying in 2s..."
                    Start-Sleep -Seconds 2
                  } else {
                    Write-Host "  Could not remove old zip, keeping new one with timestamp"
                  }
                }
              }
            }
            
            # Rename temp zip to final name
            if (-not (Test-Path `$finalZip)) {
              Move-Item -Path `$tempZip -Destination `$finalZip -Force
              Write-Host "Data saved to `$finalZip"
            } else {
              Write-Host "Data saved to `$tempZip (old zip was locked)"
            }
          }
          
          # Cleanup
          Remove-Item -Path `$tempBackup -Recurse -Force -ErrorAction SilentlyContinue
          "@
          
          $saveScriptPath = "$persistDir\auto-save.ps1"
          $saveScript | Out-File -FilePath $saveScriptPath -Encoding UTF8
          
          # Schedule auto-save every 30 minutes
          $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ExecutionPolicy Bypass -File `"$saveScriptPath`""
          $trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddMinutes(5) -RepetitionInterval (New-TimeSpan -Minutes 30)
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
          
          Register-ScheduledTask -TaskName "RDPAutoSave" -Action $action -Trigger $trigger -Settings $settings -Force
          
          Write-Host "Auto-save scheduled every 30 minutes"

      - name: Schedule chain trigger
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $chainMinutes = ${{ env.SESSION_TIMEOUT_MINUTES }} - ${{ env.CHAIN_BUFFER_MINUTES }}
          $persistDir = "${{ env.PERSIST_DIR }}"
          
          Write-Host "Chain trigger scheduled in $chainMinutes minutes"
          
          # Create scheduled task to save data and trigger next workflow
          $script = @"
          # First, run final save
          Write-Host "Running final data save before chain..."
          & powershell.exe -ExecutionPolicy Bypass -File "$persistDir\auto-save.ps1"
          
          Start-Sleep -Seconds 10
          
          # Trigger next workflow
          `$headers = @{
            "Authorization" = "Bearer $env:GH_TOKEN"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          `$body = @{
            event_type = "chain-rdp"
            client_payload = @{
              session_id = "${{ steps.session.outputs.SESSION_ID }}"
              chain_count = $([int]"${{ steps.session.outputs.CHAIN_COUNT }}" + 1)
            }
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/dispatches" -Method Post -Headers `$headers -Body `$body -ContentType "application/json"
          Write-Host "Next session triggered!"
          "@
          
          $scriptPath = "$env:TEMP\chain-trigger.ps1"
          $script | Out-File -FilePath $scriptPath -Encoding UTF8
          
          # Schedule the trigger
          $triggerTime = (Get-Date).AddMinutes($chainMinutes)
          $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ExecutionPolicy Bypass -File `"$scriptPath`""
          $trigger = New-ScheduledTaskTrigger -Once -At $triggerTime
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
          
          Register-ScheduledTask -TaskName "ChainRDP" -Action $action -Trigger $trigger -Settings $settings -Force
          
          Write-Host "Chain scheduled for: $triggerTime"

      - name: Keep session alive
        shell: pwsh
        run: |
          $endTime = (Get-Date).AddMinutes(${{ env.SESSION_TIMEOUT_MINUTES }})
          
          Write-Host "Keeping session alive until: $endTime"
          Write-Host "Press Ctrl+C in GitHub Actions to manually stop"
          
          while ((Get-Date) -lt $endTime) {
            # Heartbeat
            $remaining = ($endTime - (Get-Date)).TotalMinutes
            Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Session active - $([math]::Round($remaining)) min remaining"
            
            # Check Tailscale connection
            $status = & "C:\Program Files\Tailscale\tailscale.exe" status --json | ConvertFrom-Json
            if ($status.BackendState -ne "Running") {
              Write-Host "Tailscale disconnected, reconnecting..."
              & "C:\Program Files\Tailscale\tailscale.exe" up --authkey="${{ secrets.TAILSCALE_AUTHKEY }}"
            }
            
            # Prevent screen lock/idle
            Add-Type -AssemblyName System.Windows.Forms
            [System.Windows.Forms.Cursor]::Position = [System.Windows.Forms.Cursor]::Position
            
            Start-Sleep -Seconds 300  # 5 minute intervals
          }
          
          Write-Host "Session timeout reached, next chain should be starting..."

      # ========== SAVE DATA BEFORE EXIT ==========
      - name: Final save before exit
        if: always()
        shell: pwsh
        run: |
          $persistDir = "${{ env.PERSIST_DIR }}"
          
          Write-Host "Running final save..."
          
          if (Test-Path "$persistDir\auto-save.ps1") {
            & powershell.exe -ExecutionPolicy Bypass -File "$persistDir\auto-save.ps1"
          }
          
          # Consolidate any timestamped zips - use the newest one
          $zips = Get-ChildItem -Path $persistDir -Filter "userdata*.zip" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending
          if ($zips.Count -gt 1) {
            $newest = $zips[0]
            Write-Host "Found $($zips.Count) zip files, using newest: $($newest.Name)"
            
            # If newest isn't userdata.zip, try to rename it
            if ($newest.Name -ne "userdata.zip") {
              $finalZip = "$persistDir\userdata.zip"
              
              # Remove old userdata.zip if it exists
              if (Test-Path $finalZip) {
                try {
                  Remove-Item -Path $finalZip -Force -ErrorAction Stop
                } catch {
                  Write-Host "Could not remove old userdata.zip, will upload timestamped version"
                }
              }
              
              if (-not (Test-Path $finalZip)) {
                Move-Item -Path $newest.FullName -Destination $finalZip -Force
                Write-Host "Renamed $($newest.Name) to userdata.zip"
              }
            }
            
            # Clean up old timestamped zips
            foreach ($zip in $zips | Select-Object -Skip 1) {
              if ($zip.Name -ne "userdata.zip") {
                Remove-Item -Path $zip.FullName -Force -ErrorAction SilentlyContinue
                Write-Host "Removed old zip: $($zip.Name)"
              }
            }
          }
          
          Write-Host "Final save complete"
          Get-ChildItem -Path $persistDir | ForEach-Object { Write-Host "  $($_.Name) - $($_.Length) bytes" }

      - name: Upload persisted data
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rdp-session-data-${{ steps.session.outputs.SESSION_ID }}
          path: |
            ${{ env.PERSIST_DIR }}/userdata*.zip
            ${{ env.PERSIST_DIR }}/userprofile.txt
            ${{ env.PERSIST_DIR }}/rdpuser-home.txt
          retention-days: 7
          if-no-files-found: warn
          overwrite: true

      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          Write-Host "Cleaning up session..."
          
          # Logout from Tailscale (optional - keeps device in network for reconnection)
          # & "C:\Program Files\Tailscale\tailscale.exe" logout
          
          Write-Host "Session ended gracefully"
