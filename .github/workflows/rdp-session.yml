name: Infinite RDP Session

on:
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Session identifier (auto-generated for chains)'
        required: false
        default: ''
      chain_count:
        description: 'Chain iteration counter'
        required: false
        default: '0'
  repository_dispatch:
    types: [chain-rdp]

env:
  SESSION_TIMEOUT_MINUTES: 355  # Close to 6 hour GitHub limit
  CHAIN_BUFFER_MINUTES: 20     # Start new session 20 min before timeout (enough for setup + artifact download)

jobs:
  rdp-session:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate session info
        id: session
        shell: pwsh
        run: |
          $sessionId = "${{ github.event.inputs.session_id }}"
          if ([string]::IsNullOrEmpty($sessionId)) {
            $sessionId = [guid]::NewGuid().ToString().Substring(0,8)
          }
          
          $chainCountInput = "${{ github.event.inputs.chain_count }}"
          if ([string]::IsNullOrEmpty($chainCountInput)) {
            $chainCount = 0
          } else {
            $chainCount = [int]$chainCountInput
          }
          
          if ("${{ github.event_name }}" -eq "repository_dispatch") {
            $payloadCount = "${{ github.event.client_payload.chain_count }}"
            if (-not [string]::IsNullOrEmpty($payloadCount)) {
              $chainCount = [int]$payloadCount
            }
          }
          
          echo "SESSION_ID=$sessionId" >> $env:GITHUB_OUTPUT
          echo "CHAIN_COUNT=$chainCount" >> $env:GITHUB_OUTPUT
          echo "START_TIME=$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" >> $env:GITHUB_OUTPUT
          
          Write-Host "Session ID: $sessionId"
          Write-Host "Chain iteration: $chainCount"

      # ========== TAILSCALE SETUP ==========
      - name: Install Tailscale
        shell: pwsh
        run: |
          Write-Host "Installing Tailscale..."
          
          $url = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installer = "$env:TEMP\tailscale-setup.msi"
          
          Invoke-WebRequest -Uri $url -OutFile $installer -UseBasicParsing
          
          Start-Process msiexec.exe -ArgumentList "/i", $installer, "/quiet", "/norestart" -Wait
          
          $env:PATH += ";C:\Program Files\Tailscale"
          echo "C:\Program Files\Tailscale" >> $env:GITHUB_PATH
          
          Write-Host "Tailscale installed successfully"

      - name: Connect to Tailscale
        shell: pwsh
        env:
          TAILSCALE_AUTHKEY: ${{ secrets.TAILSCALE_AUTHKEY }}
        run: |
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $hostname = "gh-rdp-$sessionId"
          
          Write-Host "Connecting to Tailscale as: $hostname"
          
          Start-Service -Name "Tailscale" -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
          
          & "C:\Program Files\Tailscale\tailscale.exe" up `
            --authkey="$env:TAILSCALE_AUTHKEY" `
            --hostname="$hostname" `
            --accept-routes `
            --accept-dns
          
          Start-Sleep -Seconds 10
          
          $status = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          Write-Host "=========================================="
          Write-Host "TAILSCALE IP: $status"
          Write-Host "HOSTNAME: $hostname"
          Write-Host "=========================================="
          
          echo "TAILSCALE_IP=$status" >> $env:GITHUB_OUTPUT

      # ========== RDP SETUP ==========
      - name: Configure RDP Access
        shell: pwsh
        run: |
          Write-Host "Configuring RDP access..."
          
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
          
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          
          netsh advfirewall firewall add rule name="RDP-Tailscale" dir=in action=allow protocol=tcp localport=3389
          
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
          
          # Enable clipboard redirection
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "fDisableClip" -Value 0
          
          # Enable drive redirection (access local drives from RDP)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "fDisableCdm" -Value 0
          
          Write-Host "RDP configured successfully"

      - name: Create RDP User
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          
          if ([string]::IsNullOrEmpty($password)) {
            $password = -join ((65..90) + (97..122) + (48..57) + (33,35,36,37,38,42) | Get-Random -Count 16 | ForEach-Object {[char]$_})
            Write-Host "Generated password: $password"
          }
          
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          
          try {
            New-LocalUser -Name $username -Password $securePassword -FullName "RDP User" -Description "GitHub Actions RDP User" -PasswordNeverExpires
          } catch {
            Set-LocalUser -Name $username -Password $securePassword
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue
          
          Write-Host "=========================================="
          Write-Host "RDP CREDENTIALS"
          Write-Host "Username: $username"
          Write-Host "Password: (check secrets or generated above)"
          Write-Host "=========================================="

      - name: Initialize rdpuser profile
        id: rdpuser
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          
          Write-Host "Initializing user profile for rdpuser..."
          
          # Trigger proper Windows profile creation by running a process as the user
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
          
          # Start a process as rdpuser to force Windows to create the profile properly
          Start-Process -FilePath "cmd.exe" -ArgumentList "/c", "echo Profile initialized" -Credential $credential -Wait -NoNewWindow -ErrorAction SilentlyContinue
          
          Start-Sleep -Seconds 5
          
          $rdpUserHome = "C:\Users\rdpuser"
          
          # Create additional directories
          New-Item -ItemType Directory -Path "$rdpUserHome\projects" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.openclaw" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.openclaw\workspace" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.npm-global" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.local\bin" -Force | Out-Null
          
          Write-Host "rdpuser USERPROFILE: $rdpUserHome"
          
          echo "RDPUSER_HOME=$rdpUserHome" >> $env:GITHUB_OUTPUT
          
          $null = cmd /c "icacls `"$rdpUserHome`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
          Write-Host "Profile initialization complete: $rdpUserHome"

      - name: Configure environment for rdpuser
        shell: pwsh
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          
          Write-Host "Configuring environment for rdpuser: $rdpUserHome"
          
          # Create directories
          New-Item -ItemType Directory -Path "$rdpUserHome\projects" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.openclaw" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.openclaw\workspace" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.npm-global" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Roaming" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\AppData\Local" -Force | Out-Null
          New-Item -ItemType Directory -Path "$rdpUserHome\.local\bin" -Force | Out-Null
          
          # Set machine-wide environment variables
          [Environment]::SetEnvironmentVariable("OPENCLAW_STATE_DIR", "$rdpUserHome\.openclaw", "Machine")
          [Environment]::SetEnvironmentVariable("OPENCLAW_WORKSPACE", "$rdpUserHome\.openclaw\workspace", "Machine")
          [Environment]::SetEnvironmentVariable("NPM_CONFIG_PREFIX", "$rdpUserHome\.npm-global", "Machine")
          
          # Update PATH
          $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
          $newPaths = @(
            "$rdpUserHome\.npm-global",
            "$rdpUserHome\.local\bin"
          )
          foreach ($p in $newPaths) {
            if ($currentPath -notlike "*$p*") {
              $currentPath = "$p;$currentPath"
            }
          }
          [Environment]::SetEnvironmentVariable("Path", $currentPath, "Machine")
          
          $null = cmd /c "icacls `"$rdpUserHome`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
          Write-Host "Environment configured:"
          Write-Host "  OPENCLAW_STATE_DIR = $rdpUserHome\.openclaw"
          Write-Host "  OPENCLAW_WORKSPACE = $rdpUserHome\.openclaw\workspace"
          Write-Host "  NPM_CONFIG_PREFIX = $rdpUserHome\.npm-global"

      - name: Install Development Tools
        shell: pwsh
        run: |
          Write-Host "Installing development tools..."
          
          Set-ExecutionPolicy Bypass -Scope Process -Force
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
          iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
          
          $env:PATH = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          
          # Install packages with --ignore-dependencies to avoid resolution issues
          choco install -y git.install vscode.install nodejs-lts python3 7zip microsoft-windows-terminal notepadplusplus firefox --no-progress --ignore-dependencies
          
          # Install Chrome separately with --ignore-checksums (Google updates faster than Chocolatey)
          choco install -y googlechrome --ignore-checksums --no-progress
          
          # Install uBlock Origin for Chrome via policy
          $chromeExtPath = "HKLM:\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist"
          New-Item -Path $chromeExtPath -Force | Out-Null
          # uBlock Origin extension ID
          Set-ItemProperty -Path $chromeExtPath -Name "1" -Value "cjpalhdlnbpafiamejdnhcphjbkeiagm;https://clients2.google.com/service/update2/crx"
          
          # Install uBlock Origin for Firefox via policy
          $firefoxExtPath = "HKLM:\SOFTWARE\Policies\Mozilla\Firefox\Extensions\Install"
          New-Item -Path $firefoxExtPath -Force | Out-Null
          Set-ItemProperty -Path $firefoxExtPath -Name "1" -Value "https://addons.mozilla.org/firefox/downloads/latest/ublock-origin/latest.xpi"
          
          Write-Host "Development tools installed (with uBlock Origin for browsers)"
        continue-on-error: true

      - name: Configure NPM for rdpuser global installs
        shell: pwsh
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          $npmGlobalDir = "$rdpUserHome\.npm-global"
          
          Write-Host "Configuring NPM for rdpuser: $rdpUserHome"
          
          New-Item -ItemType Directory -Path $npmGlobalDir -Force | Out-Null
          
          $env:NPM_CONFIG_PREFIX = $npmGlobalDir
          $env:PATH = "$npmGlobalDir;$env:PATH"
          
          Write-Host "NPM version: $(npm --version)"
          Write-Host "NPM prefix: $(npm config get prefix)"

      - name: Install OpenClaw
        shell: pwsh
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          
          $env:NPM_CONFIG_PREFIX = "$rdpUserHome\.npm-global"
          $env:PATH = "$rdpUserHome\.npm-global;$env:PATH"
          
          Write-Host "Installing openclaw..."
          npm install -g openclaw@latest
          
          $null = cmd /c "icacls `"$rdpUserHome\.npm-global`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
          Write-Host "OpenClaw installed"

      - name: Configure OpenClaw
        shell: pwsh
        env:
          OPENCLAW_CONFIG: ${{ secrets.OPENCLAW_CONFIG }}
          OPENCLAW_AUTH_PROFILES: ${{ secrets.OPENCLAW_AUTH_PROFILES }}
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          $openclawDir = "$rdpUserHome\.openclaw"
          $openclawWorkspace = "$openclawDir\workspace"
          
          Write-Host "Configuring OpenClaw..."
          
          New-Item -ItemType Directory -Path $openclawDir -Force | Out-Null
          New-Item -ItemType Directory -Path $openclawWorkspace -Force | Out-Null
          New-Item -ItemType Directory -Path "$openclawDir\agents\main\agent" -Force | Out-Null
          
          # Inject openclaw.json from secret
          if ($env:OPENCLAW_CONFIG) {
            # Fix paths: replace any user home path with rdpuser path
            $config = $env:OPENCLAW_CONFIG
            $config = $config -replace 'C:\\\\Users\\\\[^\\\"]+', ($rdpUserHome -replace '\\', '\\\\')
            $config = $config -replace 'C:/Users/[^/\"]+', ($rdpUserHome -replace '\\', '/')
            
            $config | Out-File -FilePath "$openclawDir\openclaw.json" -Encoding UTF8
            Write-Host "Injected openclaw.json from secret (paths fixed to $rdpUserHome)"
          } else {
            Write-Host "ERROR: No OPENCLAW_CONFIG secret found"
            exit 1
          }
          
          # Inject auth-profiles.json from secret
          if ($env:OPENCLAW_AUTH_PROFILES) {
            $env:OPENCLAW_AUTH_PROFILES | Out-File -FilePath "$openclawDir\agents\main\agent\auth-profiles.json" -Encoding UTF8
            Write-Host "Injected auth-profiles.json from secret"
          } else {
            Write-Host "WARNING: No OPENCLAW_AUTH_PROFILES secret found"
          }
          
          $null = cmd /c "icacls `"$openclawDir`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
          Write-Host ""
          Write-Host "=============================================="
          Write-Host "OpenClaw configured!"
          Write-Host "=============================================="
          
      - name: Find previous workspace artifact
        id: find-artifact
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $repo = "${{ github.repository }}"
          $currentRunId = "${{ github.run_id }}"
          
          Write-Host "Checking for previous workspace artifact..."
          Write-Host "Current run ID: $currentRunId"
          
          # Check if there's another run still in progress (the one that triggered us)
          # If so, wait for it to complete and upload its artifact
          $maxWaitMinutes = 25
          $waitedMinutes = 0
          
          while ($waitedMinutes -lt $maxWaitMinutes) {
            # Get in-progress runs (excluding current)
            $inProgressRuns = gh run list --repo $repo --workflow "rdp-session.yml" --status in_progress --json databaseId 2>$null | ConvertFrom-Json
            $otherInProgress = $inProgressRuns | Where-Object { $_.databaseId -ne [int]$currentRunId }
            
            if ($otherInProgress -and $otherInProgress.Count -gt 0) {
              Write-Host "Previous session still running (run $($otherInProgress[0].databaseId)), waiting for it to upload artifact..."
              Start-Sleep -Seconds 60
              $waitedMinutes++
            } else {
              Write-Host "No other sessions in progress, proceeding with artifact download"
              break
            }
          }
          
          if ($waitedMinutes -ge $maxWaitMinutes) {
            Write-Host "WARNING: Timed out waiting for previous session, proceeding anyway"
          }
          
          # Now find the latest artifact
          $result = gh api "repos/$repo/actions/artifacts" --jq '[.artifacts[] | select(.name == "openclaw-workspace" and .expired == false)] | first | {id: .id, run_id: .workflow_run.id}' 2>$null | ConvertFrom-Json
          
          if ($result -and $result.id) {
            Write-Host "Found workspace artifact ID: $($result.id) from run: $($result.run_id)"
            echo "RUN_ID=$($result.run_id)" >> $env:GITHUB_OUTPUT
            echo "FOUND=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No previous workspace artifact found"
            echo "FOUND=false" >> $env:GITHUB_OUTPUT
          }

      - name: Restore workspace from artifact
        if: steps.find-artifact.outputs.FOUND == 'true'
        uses: actions/download-artifact@v7
        with:
          name: openclaw-workspace
          path: C:\Users\rdpuser\.openclaw\workspace
          github-token: ${{ secrets.GH_PAT }}
          run-id: ${{ steps.find-artifact.outputs.RUN_ID }}
        continue-on-error: true

      - name: Set workspace permissions
        shell: pwsh
        run: |
          $workspaceDir = "C:\Users\rdpuser\.openclaw\workspace"
          if (Test-Path $workspaceDir) {
            Write-Host "Workspace restored, setting permissions..."
          } else {
            Write-Host "No workspace restored, creating empty directory..."
            New-Item -ItemType Directory -Path $workspaceDir -Force | Out-Null
          }
          $null = cmd /c "icacls `"$workspaceDir`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
      - name: Start OpenClaw gateway
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          $password = $env:RDP_PASSWORD
          
          Write-Host "Setting up OpenClaw gateway auto-start..."
          
          # Create startup script
          $scriptContent = '$env:PATH = "C:\Users\rdpuser\.npm-global;" + $env:PATH' + "`r`n"
          $scriptContent += 'Start-Process -WindowStyle Hidden -FilePath "node" -ArgumentList "C:\Users\rdpuser\.npm-global\node_modules\openclaw\openclaw.mjs", "gateway" -WorkingDirectory "C:\Users\rdpuser\.openclaw"'
          $scriptPath = "$rdpUserHome\start-openclaw.ps1"
          $scriptContent | Out-File -FilePath $scriptPath -Encoding UTF8
          
          # Create batch wrapper
          $batchContent = '@echo off' + "`r`n"
          $batchContent += 'powershell -ExecutionPolicy Bypass -WindowStyle Hidden -File "C:\Users\rdpuser\start-openclaw.ps1"'
          $batchPath = "$rdpUserHome\start-openclaw.bat"
          $batchContent | Out-File -FilePath $batchPath -Encoding ASCII
          
          # Create scheduled task using schtasks.exe (runs at system startup as rdpuser)
          $taskName = "OpenClawGateway"
          schtasks /Create /TN $taskName /TR $batchPath /SC ONSTART /RU "rdpuser" /RP $password /RL HIGHEST /F
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Scheduled task '$taskName' created - runs at system startup"
            # Run it now
            schtasks /Run /TN $taskName
            Write-Host "Scheduled task started"
          } else {
            Write-Host "WARNING: Could not create scheduled task"
          }

      - name: Display Connection Info
        id: connection
        shell: pwsh
        run: |
          $tailscaleIp = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $chainCount = "${{ steps.session.outputs.CHAIN_COUNT }}"
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          
          Write-Host ""
          Write-Host "=============================================="
          Write-Host "       RDP SESSION READY"
          Write-Host "=============================================="
          Write-Host ""
          Write-Host "Session ID:    $sessionId"
          Write-Host "Chain Count:   $chainCount"
          Write-Host "Tailscale IP:  $tailscaleIp"
          Write-Host "Hostname:      gh-rdp-$sessionId"
          Write-Host ""
          Write-Host "Connect via RDP:"
          Write-Host "  Address:  $tailscaleIp:3389"
          Write-Host "  -or-      gh-rdp-$sessionId:3389"
          Write-Host "  Username: rdpuser"
          Write-Host "  Password: (from RDP_PASSWORD secret)"
          Write-Host ""
          Write-Host "rdpuser profile path: $rdpUserHome"
          Write-Host ""
          Write-Host "OpenClaw:"
          Write-Host "  Config: $rdpUserHome\.openclaw\openclaw.json"
          Write-Host "  Workspace: $rdpUserHome\.openclaw\workspace"
          Write-Host "  Start: openclaw gateway"
          Write-Host ""
          Write-Host "User directories:"
          Write-Host "  $rdpUserHome\projects"
          Write-Host "  $rdpUserHome\.npm-global"
          Write-Host ""
          Write-Host "Session will auto-chain in ~${{ env.SESSION_TIMEOUT_MINUTES }} minutes"
          Write-Host "=============================================="

      - name: Schedule chain trigger
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $chainMinutes = ${{ env.SESSION_TIMEOUT_MINUTES }} - ${{ env.CHAIN_BUFFER_MINUTES }}
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $nextChainCount = [int]"${{ steps.session.outputs.CHAIN_COUNT }}" + 1
          $repo = "${{ github.repository }}"
          $token = "${{ secrets.GH_PAT }}"
          $rdpUserHome = "C:\Users\rdpuser"
          
          Write-Host "Chain trigger scheduled in $chainMinutes minutes"
          
          # Create chain trigger script
          $chainScript = @"
          Write-Host "Triggering next session..."
          `$headers = @{
            'Authorization' = "Bearer $token"
            'Accept' = 'application/vnd.github.v3+json'
          }
          `$body = @{
            event_type = 'chain-rdp'
            client_payload = @{
              session_id = '$sessionId'
              chain_count = $nextChainCount
            }
          } | ConvertTo-Json
          
          Invoke-RestMethod -Uri "https://api.github.com/repos/$repo/dispatches" -Method Post -Headers `$headers -Body `$body -ContentType 'application/json'
          Write-Host "Chain triggered! Next session will wait for this session to finish uploading artifact."
          "@
          
          $scriptPath = "$rdpUserHome\chain-trigger.ps1"
          $chainScript | Out-File -FilePath $scriptPath -Encoding UTF8
          
          $triggerTime = (Get-Date).AddMinutes($chainMinutes)
          $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ExecutionPolicy Bypass -File `"$scriptPath`""
          $trigger = New-ScheduledTaskTrigger -Once -At $triggerTime
          $settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
          
          Register-ScheduledTask -TaskName "ChainRDP" -Action $action -Trigger $trigger -Settings $settings -Force
          
          Write-Host "Chain scheduled for: $triggerTime"

      - name: Keep session alive
        shell: pwsh
        run: |
          $endTime = (Get-Date).AddMinutes(${{ env.SESSION_TIMEOUT_MINUTES }})
          $rdpUserHome = "C:\Users\rdpuser"
          
          # Keep alive loop - also checks and restarts OpenClaw every 5 minutes
          while ((Get-Date) -lt $endTime) {
            Write-Host "Session alive at $(Get-Date -Format 'HH:mm:ss')..."
            
            # Check if OpenClaw is running, restart if not
            $nodeProcs = Get-Process -Name "node" -ErrorAction SilentlyContinue
            if (-not $nodeProcs) {
              Write-Host "OpenClaw not running, restarting..."
              $env:PATH = "$rdpUserHome\.npm-global;$env:PATH"
              Start-Process -WindowStyle Hidden -FilePath "node" -ArgumentList "$rdpUserHome\.npm-global\node_modules\openclaw\openclaw.mjs", "gateway" -WorkingDirectory "$rdpUserHome\.openclaw"
              Write-Host "OpenClaw restarted"
            }
            
            Start-Sleep -Seconds 300
          }
          
          Write-Host "Session timeout reached"

      - name: Save updated OpenClaw configs to secrets
        if: always()
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $rdpUserHome = "C:\Users\rdpuser"
          $openclawDir = "$rdpUserHome\.openclaw"
          $repo = "${{ github.repository }}"
          
          Write-Host "Saving updated OpenClaw configs to GitHub secrets..."
          
          $configFile = "$openclawDir\openclaw.json"
          $authFile = "$openclawDir\agents\main\agent\auth-profiles.json"
          
          if (-not (Test-Path $configFile)) {
            Write-Host "No openclaw.json found, skipping"
            exit 0
          }
          
          # Get repo public key for encrypting secrets
          $keyResponse = gh api "/repos/$repo/actions/secrets/public-key" | ConvertFrom-Json
          $keyId = $keyResponse.key_id
          $publicKey = $keyResponse.key
          
          # Function to encrypt secret using libsodium (via .NET)
          function Encrypt-Secret {
            param($plaintext, $publicKeyBase64)
            
            Add-Type -AssemblyName System.Security
            
            # Use gh secret set which handles encryption automatically
            return $plaintext
          }
          
          # Update OPENCLAW_CONFIG secret
          if (Test-Path $configFile) {
            Write-Host "Updating OPENCLAW_CONFIG secret..."
            $configContent = Get-Content $configFile -Raw
            $configContent | gh secret set OPENCLAW_CONFIG --repo $repo
            Write-Host "Updated OPENCLAW_CONFIG"
          }
          
          # Update OPENCLAW_AUTH_PROFILES secret
          if (Test-Path $authFile) {
            Write-Host "Updating OPENCLAW_AUTH_PROFILES secret..."
            $authContent = Get-Content $authFile -Raw
            $authContent | gh secret set OPENCLAW_AUTH_PROFILES --repo $repo
            Write-Host "Updated OPENCLAW_AUTH_PROFILES"
          }
          
          Write-Host "Secrets updated with refreshed tokens!"
        continue-on-error: true

      - name: Save workspace to artifact
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: openclaw-workspace
          path: C:\Users\rdpuser\.openclaw\workspace
          retention-days: 90
          if-no-files-found: ignore
          overwrite: true

      - name: Cleanup old workflow runs
        if: always()
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $repo = "${{ github.repository }}"
          $currentRunId = "${{ github.run_id }}"
          
          Write-Host "Cleaning up old workflow runs (keeping 2 most recent)..."
          
          # Get all runs for this workflow, sorted by created_at desc
          $runs = gh run list --repo $repo --workflow "rdp-session.yml" --limit 50 --json databaseId,status,createdAt 2>$null | ConvertFrom-Json
          
          if ($runs -and $runs.Count -gt 2) {
            # Keep the 2 most recent runs (current + previous for artifact download during overlap)
            # Delete everything else
            $toKeep = $runs | Select-Object -First 2
            $toDelete = $runs | Select-Object -Skip 2
            
            Write-Host "Keeping runs: $($toKeep.databaseId -join ', ')"
            
            foreach ($run in $toDelete) {
              Write-Host "Deleting old run: $($run.databaseId) (created: $($run.createdAt))"
              gh run delete $run.databaseId --repo $repo 2>$null
            }
            Write-Host "Deleted $($toDelete.Count) old run(s)"
          } else {
            Write-Host "No old runs to clean up (keeping 2 most recent)"
          }
        continue-on-error: true
