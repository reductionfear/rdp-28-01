name: Infinite RDP Session

on:
  workflow_dispatch:
    inputs:
      session_id:
        description: 'Session identifier (auto-generated for chains)'
        required: false
        default: ''
      chain_count:
        description: 'Chain iteration counter'
        required: false
        default: '0'
      openclaw_cache_version:
        description: 'Bump to force openclaw upgrade (e.g. v1 -> v2)'
        required: false
        default: 'v1'
  repository_dispatch:
    types: [chain-rdp]

env:
  SESSION_TIMEOUT_MINUTES: 355  # Close to 6 hour GitHub limit
  CHAIN_BUFFER_MINUTES: 10     # Start new session 10 min before timeout (cached setup takes ~3-5 min)

jobs:
  rdp-session:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate session info
        id: session
        shell: pwsh
        run: |
          $sessionId = "${{ github.event.inputs.session_id }}"
          if ([string]::IsNullOrEmpty($sessionId)) {
            $sessionId = [guid]::NewGuid().ToString().Substring(0,8)
          }
          
          $chainCountInput = "${{ github.event.inputs.chain_count }}"
          if ([string]::IsNullOrEmpty($chainCountInput)) {
            $chainCount = 0
          } else {
            $chainCount = [int]$chainCountInput
          }
          
          # Resolve openclaw cache version (from input or chained payload)
          $openclawCacheVersion = "${{ github.event.inputs.openclaw_cache_version }}"
          
          if ("${{ github.event_name }}" -eq "repository_dispatch") {
            $payloadCount = "${{ github.event.client_payload.chain_count }}"
            if (-not [string]::IsNullOrEmpty($payloadCount)) {
              $chainCount = [int]$payloadCount
            }
            $payloadCacheVersion = "${{ github.event.client_payload.openclaw_cache_version }}"
            if (-not [string]::IsNullOrEmpty($payloadCacheVersion)) {
              $openclawCacheVersion = $payloadCacheVersion
            }
          }
          
          if ([string]::IsNullOrEmpty($openclawCacheVersion)) {
            $openclawCacheVersion = "v1"
          }
          
          # Record job start time as ticks for accurate timeout calculation later
          $jobStartTicks = (Get-Date).Ticks
          
          echo "SESSION_ID=$sessionId" >> $env:GITHUB_OUTPUT
          echo "CHAIN_COUNT=$chainCount" >> $env:GITHUB_OUTPUT
          echo "OPENCLAW_CACHE_VERSION=$openclawCacheVersion" >> $env:GITHUB_OUTPUT
          echo "JOB_START_TICKS=$jobStartTicks" >> $env:GITHUB_OUTPUT
          
          Write-Host "Session: $sessionId | Chain: $chainCount | Cache: $openclawCacheVersion"

      # ========== DEPENDENCY CACHING ==========
      # NOTE: Chocolatey caching removed intentionally. windows-latest already has
      # Git, Node.js, Python pre-installed. Chocolatey installs register in the
      # Windows registry which is NOT cached by actions/cache, causing restored
      # files to be non-functional (broken shims, missing PATH entries, etc.).
      # Installing the few missing tools fresh each time (~2-3 min) is more reliable.

      - name: Restore Tailscale installer cache
        id: cache-tailscale
        uses: actions/cache/restore@v5
        with:
          path: C:\tailscale-cache
          key: tailscale-v1-${{ runner.os }}

      - name: Restore npm global packages cache
        id: cache-npm-global
        uses: actions/cache/restore@v5
        with:
          path: C:\Users\rdpuser\.npm-global
          key: npm-global-openclaw-${{ steps.session.outputs.OPENCLAW_CACHE_VERSION }}-${{ runner.os }}

      # ========== TAILSCALE SETUP ==========
      - name: Install Tailscale
        shell: pwsh
        run: |
          $cacheDir = "C:\tailscale-cache"
          $cachedMsi = "$cacheDir\tailscale-setup.msi"
          
          if (Test-Path $cachedMsi) {
            Write-Host "Tailscale: installing from cache"
            $installer = $cachedMsi
          } else {
            Write-Host "Tailscale: downloading (will be cached)"
            New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
            $url = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
            $installer = $cachedMsi
            Invoke-WebRequest -Uri $url -OutFile $installer -UseBasicParsing
          }
          
          Start-Process msiexec.exe -ArgumentList "/i", $installer, "/quiet", "/norestart" -Wait
          
          $env:PATH += ";C:\Program Files\Tailscale"
          echo "C:\Program Files\Tailscale" >> $env:GITHUB_PATH

      - name: Connect to Tailscale
        shell: pwsh
        env:
          TAILSCALE_AUTHKEY: ${{ secrets.TAILSCALE_AUTHKEY }}
        run: |
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $hostname = "gh-rdp-$sessionId"
          
          Start-Service -Name "Tailscale" -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
          
          & "C:\Program Files\Tailscale\tailscale.exe" up `
            --authkey="$env:TAILSCALE_AUTHKEY" `
            --hostname="$hostname" `
            --accept-routes `
            --accept-dns
          
          Start-Sleep -Seconds 10
          
          $status = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          Write-Host "=========================================="
          Write-Host "TAILSCALE IP: $status"
          Write-Host "HOSTNAME: $hostname"
          Write-Host "=========================================="

      # ========== RDP SETUP ==========
      - name: Configure RDP Access
        shell: pwsh
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
          Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
          netsh advfirewall firewall add rule name="RDP-Tailscale" dir=in action=allow protocol=tcp localport=3389
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "fDisableClip" -Value 0
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "fDisableCdm" -Value 0
          Write-Host "RDP configured"

      - name: Create RDP User
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          
          if ([string]::IsNullOrEmpty($password)) {
            $password = -join ((65..90) + (97..122) + (48..57) + (33,35,36,37,38,42) | Get-Random -Count 16 | ForEach-Object {[char]$_})
            Write-Host "Generated password: $password"
          }
          
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          
          try {
            New-LocalUser -Name $username -Password $securePassword -FullName "RDP User" -Description "GitHub Actions RDP User" -PasswordNeverExpires
          } catch {
            Set-LocalUser -Name $username -Password $securePassword
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $username -ErrorAction SilentlyContinue
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username -ErrorAction SilentlyContinue
          Write-Host "RDP user '$username' ready"

      - name: Initialize rdpuser profile and environment
        id: rdpuser
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $username = "rdpuser"
          $password = $env:RDP_PASSWORD
          $rdpUserHome = "C:\Users\rdpuser"
          
          # Trigger proper Windows profile creation by running a process as the user
          $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($username, $securePassword)
          Start-Process -FilePath "cmd.exe" -ArgumentList "/c", "echo Profile initialized" -Credential $credential -Wait -NoNewWindow -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
          
          # Create all directories
          $dirs = @(
            "$rdpUserHome\projects",
            "$rdpUserHome\.openclaw",
            "$rdpUserHome\.openclaw\workspace",
            "$rdpUserHome\.openclaw\agents\main\agent",
            "$rdpUserHome\.npm-global",
            "$rdpUserHome\.local\bin",
            "$rdpUserHome\AppData\Roaming",
            "$rdpUserHome\AppData\Local"
          )
          $dirs | ForEach-Object { New-Item -ItemType Directory -Path $_ -Force | Out-Null }
          
          # Set machine-wide environment variables
          [Environment]::SetEnvironmentVariable("OPENCLAW_STATE_DIR", "$rdpUserHome\.openclaw", "Machine")
          [Environment]::SetEnvironmentVariable("OPENCLAW_WORKSPACE", "$rdpUserHome\.openclaw\workspace", "Machine")
          [Environment]::SetEnvironmentVariable("NPM_CONFIG_PREFIX", "$rdpUserHome\.npm-global", "Machine")
          
          # Update PATH
          $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
          foreach ($p in @("$rdpUserHome\.npm-global", "$rdpUserHome\.local\bin")) {
            if ($currentPath -notlike "*$p*") { $currentPath = "$p;$currentPath" }
          }
          [Environment]::SetEnvironmentVariable("Path", $currentPath, "Machine")
          
          # Grant rdpuser full control
          $null = cmd /c "icacls `"$rdpUserHome`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          
          echo "RDPUSER_HOME=$rdpUserHome" >> $env:GITHUB_OUTPUT
          Write-Host "Profile and environment configured: $rdpUserHome"

      - name: Install Development Tools
        shell: pwsh
        run: |
          # Ensure Chocolatey is available (pre-installed on windows-latest)
          $chocoCmd = Get-Command choco -ErrorAction SilentlyContinue
          if (-not $chocoCmd) {
            Write-Host "Chocolatey not found, installing..."
            Set-ExecutionPolicy Bypass -Scope Process -Force
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
            iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            $env:PATH = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          } else {
            Write-Host "Chocolatey already available at: $($chocoCmd.Source)"
          }
          
          # Only install tools that are NOT already on the runner
          # windows-latest has: Git, Node.js, Python, 7-Zip pre-installed
          $tools = @(
            @{ Name = "vscode"; Test = "C:\Program Files\Microsoft VS Code\Code.exe"; Pkg = "vscode.install" },
            @{ Name = "notepad++"; Test = "C:\Program Files\Notepad++\notepad++.exe"; Pkg = "notepadplusplus" },
            @{ Name = "firefox"; Test = "C:\Program Files\Mozilla Firefox\firefox.exe"; Pkg = "firefox" },
            @{ Name = "terminal"; Test = ""; Pkg = "microsoft-windows-terminal" }
          )
          
          $toInstall = @()
          foreach ($tool in $tools) {
            if ($tool.Test -and (Test-Path $tool.Test)) {
              Write-Host "  SKIP: $($tool.Name) already installed"
            } else {
              Write-Host "  INSTALL: $($tool.Name)"
              $toInstall += $tool.Pkg
            }
          }
          
          if ($toInstall.Count -gt 0) {
            $pkgList = $toInstall -join " "
            Write-Host "Installing: $pkgList"
            choco install -y $toInstall --no-progress --ignore-dependencies
          } else {
            Write-Host "All tools already present"
          }
          
          # Chrome: install separately with --ignore-checksums (Google updates faster than Chocolatey)
          if (-not (Test-Path "C:\Program Files\Google\Chrome\Application\chrome.exe")) {
            Write-Host "  INSTALL: Chrome"
            choco install -y googlechrome --ignore-checksums --no-progress
          } else {
            Write-Host "  SKIP: Chrome already installed"
          }
          
          # Install uBlock Origin for Chrome via policy
          $chromeExtPath = "HKLM:\SOFTWARE\Policies\Google\Chrome\ExtensionInstallForcelist"
          New-Item -Path $chromeExtPath -Force | Out-Null
          Set-ItemProperty -Path $chromeExtPath -Name "1" -Value "cjpalhdlnbpafiamejdnhcphjbkeiagm;https://clients2.google.com/service/update2/crx"
          
          # Install uBlock Origin for Firefox via policy
          $firefoxExtPath = "HKLM:\SOFTWARE\Policies\Mozilla\Firefox\Extensions\Install"
          New-Item -Path $firefoxExtPath -Force | Out-Null
          Set-ItemProperty -Path $firefoxExtPath -Name "1" -Value "https://addons.mozilla.org/firefox/downloads/latest/ublock-origin/latest.xpi"
        continue-on-error: true

      - name: Install OpenClaw
        shell: pwsh
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          
          $env:NPM_CONFIG_PREFIX = "$rdpUserHome\.npm-global"
          $env:PATH = "$rdpUserHome\.npm-global;$env:PATH"
          
          # Validate whether cache actually restored a working openclaw
          $openclawBin = "$rdpUserHome\.npm-global\node_modules\openclaw\openclaw.mjs"
          $cacheWorking = $false
          
          if ("${{ steps.cache-npm-global.outputs.cache-hit }}" -eq "true") {
            if (Test-Path $openclawBin) {
              Write-Host "Cache hit AND openclaw binary exists - validating..."
              try {
                $ver = node $openclawBin --version 2>&1
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "OpenClaw restored from cache: $ver"
                  $cacheWorking = $true
                } else {
                  Write-Host "WARNING: Cached openclaw binary failed validation (exit $LASTEXITCODE)"
                }
              } catch {
                Write-Host "WARNING: Cached openclaw binary threw error: $_"
              }
            } else {
              Write-Host "WARNING: Cache hit but openclaw binary not found at $openclawBin"
            }
          } else {
            Write-Host "No npm cache hit (version: ${{ steps.session.outputs.OPENCLAW_CACHE_VERSION }})"
          }
          
          if (-not $cacheWorking) {
            Write-Host "Installing openclaw@latest fresh..."
            npm install -g openclaw@latest
          }
          
          $null = cmd /c "icacls `"$rdpUserHome\.npm-global`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0

      - name: Configure OpenClaw
        shell: pwsh
        env:
          OPENCLAW_CONFIG: ${{ secrets.OPENCLAW_CONFIG }}
          OPENCLAW_AUTH_PROFILES: ${{ secrets.OPENCLAW_AUTH_PROFILES }}
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          $openclawDir = "$rdpUserHome\.openclaw"
          
          # Inject openclaw.json from secret
          if ($env:OPENCLAW_CONFIG) {
            # Fix paths: replace any user home path with rdpuser path
            $config = $env:OPENCLAW_CONFIG
            $config = $config -replace 'C:\\\\Users\\\\[^\\\"]+', ($rdpUserHome -replace '\\', '\\\\')
            $config = $config -replace 'C:/Users/[^/\"]+', ($rdpUserHome -replace '\\', '/')
            
            $config | Out-File -FilePath "$openclawDir\openclaw.json" -Encoding UTF8
            Write-Host "Injected openclaw.json from secret (paths fixed to $rdpUserHome)"
          } else {
            Write-Host "ERROR: No OPENCLAW_CONFIG secret found"
            exit 1
          }
          
          # Inject auth-profiles.json from secret
          if ($env:OPENCLAW_AUTH_PROFILES) {
            $env:OPENCLAW_AUTH_PROFILES | Out-File -FilePath "$openclawDir\agents\main\agent\auth-profiles.json" -Encoding UTF8
            Write-Host "Injected auth-profiles.json from secret"
          } else {
            Write-Host "WARNING: No OPENCLAW_AUTH_PROFILES secret found"
          }
          
          $null = cmd /c "icacls `"$openclawDir`" /grant rdpuser:(OI)(CI)F /T /Q 2>&1"
          $global:LASTEXITCODE = 0
          Write-Host "OpenClaw configured"
          
      - name: Find previous workspace artifact
        id: find-artifact
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $repo = "${{ github.repository }}"
          $currentRunId = "${{ github.run_id }}"
          
          # Brief wait for previous session's artifact upload
          $maxWaitMinutes = 2
          $waitedMinutes = 0
          
          while ($waitedMinutes -lt $maxWaitMinutes) {
            $inProgressRuns = gh run list --repo $repo --workflow "rdp-session.yml" --status in_progress --json databaseId 2>$null | ConvertFrom-Json
            $otherInProgress = $inProgressRuns | Where-Object { $_.databaseId -ne [int64]$currentRunId }
            
            if ($otherInProgress -and $otherInProgress.Count -gt 0) {
              Write-Host "Previous session still running, waiting..."
              Start-Sleep -Seconds 30
              $waitedMinutes += 0.5
            } else {
              break
            }
          }
          
          # Find the latest artifact
          $result = gh api "repos/$repo/actions/artifacts" --jq '[.artifacts[] | select(.name == "openclaw-workspace" and .expired == false)] | first | {id: .id, run_id: .workflow_run.id}' 2>$null | ConvertFrom-Json
          
          if ($result -and $result.id) {
            Write-Host "Found workspace artifact from run: $($result.run_id)"
            echo "RUN_ID=$($result.run_id)" >> $env:GITHUB_OUTPUT
            echo "FOUND=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No previous workspace artifact found"
            echo "FOUND=false" >> $env:GITHUB_OUTPUT
          }

      - name: Restore workspace from artifact
        if: steps.find-artifact.outputs.FOUND == 'true'
        uses: actions/download-artifact@v7
        with:
          name: openclaw-workspace
          path: C:\Users\rdpuser\.openclaw\workspace
          github-token: ${{ secrets.GH_PAT }}
          run-id: ${{ steps.find-artifact.outputs.RUN_ID }}
        continue-on-error: true

      - name: Start OpenClaw gateway
        shell: pwsh
        env:
          RDP_PASSWORD: ${{ secrets.RDP_PASSWORD }}
        run: |
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          $password = $env:RDP_PASSWORD
          
          # Create startup script
          $scriptContent = '$env:PATH = "C:\Users\rdpuser\.npm-global;" + $env:PATH' + "`r`n"
          $scriptContent += 'Start-Process -WindowStyle Hidden -FilePath "node" -ArgumentList "C:\Users\rdpuser\.npm-global\node_modules\openclaw\openclaw.mjs", "gateway" -WorkingDirectory "C:\Users\rdpuser\.openclaw"'
          $scriptPath = "$rdpUserHome\start-openclaw.ps1"
          $scriptContent | Out-File -FilePath $scriptPath -Encoding UTF8
          
          # Create batch wrapper
          $batchContent = '@echo off' + "`r`n"
          $batchContent += 'powershell -ExecutionPolicy Bypass -WindowStyle Hidden -File "C:\Users\rdpuser\start-openclaw.ps1"'
          $batchPath = "$rdpUserHome\start-openclaw.bat"
          $batchContent | Out-File -FilePath $batchPath -Encoding ASCII
          
          # Create scheduled task using schtasks.exe (runs at system startup as rdpuser)
          $taskName = "OpenClawGateway"
          schtasks /Create /TN $taskName /TR $batchPath /SC ONSTART /RU "rdpuser" /RP $password /RL HIGHEST /F
          
          if ($LASTEXITCODE -eq 0) {
            schtasks /Run /TN $taskName
            Write-Host "OpenClaw gateway scheduled task created and started"
          } else {
            Write-Host "WARNING: Could not create scheduled task"
          }

      - name: Display Connection Info
        shell: pwsh
        run: |
          $tailscaleIp = & "C:\Program Files\Tailscale\tailscale.exe" ip -4
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $chainCount = "${{ steps.session.outputs.CHAIN_COUNT }}"
          $rdpUserHome = "${{ steps.rdpuser.outputs.RDPUSER_HOME }}"
          
          Write-Host ""
          Write-Host "=============================================="
          Write-Host "       RDP SESSION READY"
          Write-Host "=============================================="
          Write-Host ""
          Write-Host "Session ID:    $sessionId"
          Write-Host "Chain Count:   $chainCount"
          Write-Host "Tailscale IP:  $tailscaleIp"
          Write-Host "Hostname:      gh-rdp-$sessionId"
          Write-Host ""
          Write-Host "Connect via RDP:"
          Write-Host "  Address:  $tailscaleIp:3389"
          Write-Host "  -or-      gh-rdp-$sessionId:3389"
          Write-Host "  Username: rdpuser"
          Write-Host "  Password: (from RDP_PASSWORD secret)"
          Write-Host ""
          Write-Host "rdpuser profile path: $rdpUserHome"
          Write-Host ""
          Write-Host "OpenClaw:"
          Write-Host "  Config: $rdpUserHome\.openclaw\openclaw.json"
          Write-Host "  Workspace: $rdpUserHome\.openclaw\workspace"
          Write-Host "  Start: openclaw gateway"
          Write-Host "  Cache version: ${{ steps.session.outputs.OPENCLAW_CACHE_VERSION }}"
          Write-Host ""
          Write-Host "Upgrade openclaw:"
          Write-Host "  Cancel this workflow from GitHub Actions UI"
          Write-Host "  (auto-saves workspace, toggles cache version, triggers new session)"
          Write-Host ""
          Write-Host "User directories:"
          Write-Host "  $rdpUserHome\projects"
          Write-Host "  $rdpUserHome\.npm-global"
          Write-Host ""
          Write-Host "Session will auto-chain in ~${{ env.SESSION_TIMEOUT_MINUTES }} minutes"
          Write-Host "=============================================="

      - name: Keep session alive (phase 1 - until chain trigger)
        id: keepalive
        shell: pwsh
        run: |
          # Calculate end time from JOB START, not from now.
          # Phase 1 starts after setup (~5-20 min), so using (Get-Date) here
          # would overshoot the 360-min GitHub limit and get killed before chaining.
          $jobStart = [DateTime]::new([long]"${{ steps.session.outputs.JOB_START_TICKS }}")
          $chainMinutes = ${{ env.SESSION_TIMEOUT_MINUTES }} - ${{ env.CHAIN_BUFFER_MINUTES }}
          $endTime = $jobStart.AddMinutes($chainMinutes)
          $rdpUserHome = "C:\Users\rdpuser"
          
          $setupElapsed = [math]::Round(((Get-Date) - $jobStart).TotalMinutes, 1)
          $remainingMinutes = [math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)
          
          Write-Host "Phase 1: Keep alive until chain trigger"
          Write-Host "  Job started:       $($jobStart.ToString('HH:mm:ss'))"
          Write-Host "  Setup took:        $setupElapsed min"
          Write-Host "  Chain trigger at:  $($endTime.ToString('HH:mm:ss')) ($chainMinutes min from job start)"
          Write-Host "  Remaining:         $remainingMinutes min"
          Write-Host "  Upgrade openclaw:  Cancel workflow from GitHub Actions UI"
          
          if ((Get-Date) -ge $endTime) {
            Write-Host "WARNING: Setup took longer than chain window! Proceeding to chain immediately."
          }
          
          # Keep alive loop - also checks and restarts OpenClaw every 5 minutes
          while ((Get-Date) -lt $endTime) {
            $left = [math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)
            Write-Host "Session alive at $(Get-Date -Format 'HH:mm:ss') ($left min until chain)..."
            
            # Check if OpenClaw is running, restart if not
            $nodeProcs = Get-Process -Name "node" -ErrorAction SilentlyContinue
            if (-not $nodeProcs) {
              Write-Host "OpenClaw not running, restarting..."
              $env:PATH = "$rdpUserHome\.npm-global;$env:PATH"
              Start-Process -WindowStyle Hidden -FilePath "node" -ArgumentList "$rdpUserHome\.npm-global\node_modules\openclaw\openclaw.mjs", "gateway" -WorkingDirectory "$rdpUserHome\.openclaw"
              Write-Host "OpenClaw restarted"
            }
            
            Start-Sleep -Seconds 300
          }
          
          Write-Host "Phase 1 complete - proceeding to save and chain"

      - name: Save secrets before chain
        if: always()
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $rdpUserHome = "C:\Users\rdpuser"
          $repo = "${{ github.repository }}"
          $configFile = "$rdpUserHome\.openclaw\openclaw.json"
          $authFile = "$rdpUserHome\.openclaw\agents\main\agent\auth-profiles.json"
          
          if (Test-Path $configFile) {
            Get-Content $configFile -Raw | gh secret set OPENCLAW_CONFIG --repo $repo
          }
          if (Test-Path $authFile) {
            Get-Content $authFile -Raw | gh secret set OPENCLAW_AUTH_PROFILES --repo $repo
          }
          Write-Host "Secrets saved"
        continue-on-error: true

      - name: Clean workspace before upload
        if: always()
        shell: pwsh
        run: |
          $workspace = "C:\Users\rdpuser\.openclaw\workspace"
          
          if (-not (Test-Path $workspace)) {
            Write-Host "No workspace to clean"
            exit 0
          }
          
          Write-Host "Cleaning transient/large files from workspace before upload..."
          
          # Remove known transient directories
          $transientNames = @("downloads", "temp", "tmp", "cache", ".cache", "node_modules", "__pycache__", ".venv", "venv")
          foreach ($name in $transientNames) {
            Get-ChildItem -Path $workspace -Directory -Recurse -Filter $name -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "  Removing dir: $($_.FullName)"
              Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          
          # Remove large media/binary files (>50MB or known extensions)
          $largeExtensions = @("*.mp4", "*.mkv", "*.avi", "*.mov", "*.webm", "*.mp3", "*.wav", "*.flac",
                               "*.zip", "*.tar", "*.gz", "*.7z", "*.rar",
                               "*.iso", "*.img", "*.exe", "*.msi",
                               "*.bin", "*.dat", "*.psd", "*.raw")
          foreach ($ext in $largeExtensions) {
            Get-ChildItem -Path $workspace -Recurse -Filter $ext -File -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "  Removing file: $($_.FullName) ($([math]::Round($_.Length/1MB, 1)) MB)"
              Remove-Item -Path $_.FullName -Force -ErrorAction SilentlyContinue
            }
          }
          
          # Remove any files >50MB that slipped through
          Get-ChildItem -Path $workspace -Recurse -File -ErrorAction SilentlyContinue | Where-Object { $_.Length -gt 50MB } | ForEach-Object {
            Write-Host "  Removing large file: $($_.FullName) ($([math]::Round($_.Length/1MB, 1)) MB)"
            Remove-Item -Path $_.FullName -Force -ErrorAction SilentlyContinue
          }
          
          # Remove broken symlinks and validate all files are accessible
          Get-ChildItem -Path $workspace -Recurse -File -ErrorAction SilentlyContinue | ForEach-Object {
            try {
              $null = [System.IO.File]::OpenRead($_.FullName).Close()
            } catch {
              Write-Host "  Removing inaccessible file: $($_.FullName)"
              Remove-Item -Path $_.FullName -Force -ErrorAction SilentlyContinue
            }
          }
          
          # Remove empty directories left behind
          do {
            $emptyDirs = Get-ChildItem -Path $workspace -Directory -Recurse -ErrorAction SilentlyContinue |
              Where-Object { @(Get-ChildItem -Path $_.FullName -Force -ErrorAction SilentlyContinue).Count -eq 0 }
            $emptyDirs | ForEach-Object {
              Write-Host "  Removing empty dir: $($_.FullName)"
              Remove-Item -Path $_.FullName -Force -ErrorAction SilentlyContinue
            }
          } while ($emptyDirs -and $emptyDirs.Count -gt 0)
          
          # Summary
          $fileCount = (Get-ChildItem -Path $workspace -Recurse -File -ErrorAction SilentlyContinue).Count
          $totalSize = (Get-ChildItem -Path $workspace -Recurse -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
          $sizeMB = [math]::Round($totalSize / 1MB, 1)
          Write-Host "Workspace ready for upload: $fileCount files, ${sizeMB} MB"

      - name: Upload workspace artifact (for next session)
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: openclaw-workspace
          path: C:\Users\rdpuser\.openclaw\workspace
          retention-days: 90
          if-no-files-found: ignore
          overwrite: true

      - name: Trigger next session
        if: always()
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          $sessionId = "${{ steps.session.outputs.SESSION_ID }}"
          $nextChainCount = [int]"${{ steps.session.outputs.CHAIN_COUNT }}" + 1
          $openclawCacheVersion = "${{ steps.session.outputs.OPENCLAW_CACHE_VERSION }}"
          $repo = "${{ github.repository }}"
          
          # If workflow was cancelled, toggle version to force openclaw upgrade
          $keepaliveOutcome = "${{ steps.keepalive.outcome }}"
          if ($keepaliveOutcome -eq "cancelled") {
            # Toggle between v1 and v2
            if ($openclawCacheVersion -eq "v1") {
              $newVersion = "v2"
            } else {
              $newVersion = "v1"
            }
            Write-Host "=========================================="
            Write-Host "CANCEL DETECTED - UPGRADING OPENCLAW"
            Write-Host "  Previous cache version: $openclawCacheVersion"
            Write-Host "  New cache version:      $newVersion"
            Write-Host "=========================================="
            $openclawCacheVersion = $newVersion
          }
          
          Write-Host "Triggering next session (chain count: $nextChainCount, openclaw cache: $openclawCacheVersion)..."
          
          $body = @{
            event_type = 'chain-rdp'
            client_payload = @{
              session_id = $sessionId
              chain_count = $nextChainCount
              openclaw_cache_version = $openclawCacheVersion
            }
          } | ConvertTo-Json -Compress
          
          # Retry up to 3 times with backoff
          $maxRetries = 3
          for ($i = 1; $i -le $maxRetries; $i++) {
            try {
              $body | gh api "repos/$repo/dispatches" --method POST --input -
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Next session triggered successfully on attempt $i"
                break
              }
              Write-Host "WARNING: gh api exited with code $LASTEXITCODE (attempt $i/$maxRetries)"
            } catch {
              Write-Host "WARNING: Exception on attempt $i/$maxRetries - $_"
            }
            if ($i -lt $maxRetries) {
              $wait = $i * 15
              Write-Host "Retrying in $wait seconds..."
              Start-Sleep -Seconds $wait
            } else {
              Write-Host "ERROR: All $maxRetries attempts to trigger next session failed!"
            }
          }

      # ========== EXPLICIT CACHE SAVE ==========
      # actions/cache/restore does not register a post-hook, so we must save
      # explicitly. This runs before the infinite phase-2 loop to guarantee
      # caches are persisted even when GitHub kills the job at 360 min.

      - name: Save Tailscale installer cache
        if: ${{ always() && steps.cache-tailscale.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@v5
        with:
          path: C:\tailscale-cache
          key: tailscale-v1-${{ runner.os }}

      - name: Save npm global packages cache
        if: ${{ always() && steps.cache-npm-global.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@v5
        with:
          path: C:\Users\rdpuser\.npm-global
          key: npm-global-openclaw-${{ steps.session.outputs.OPENCLAW_CACHE_VERSION }}-${{ runner.os }}

      - name: Keep session alive (phase 2 - until timeout)
        if: ${{ !cancelled() }}
        shell: pwsh
        run: |
          $rdpUserHome = "C:\Users\rdpuser"
          
          Write-Host "Phase 2: Continuing until job timeout"
          Write-Host "Next session is already running with fresh artifact"
          Write-Host "You can continue working until GitHub terminates this job"
          
          # Run indefinitely - GitHub will kill us at 360 min
          while ($true) {
            Write-Host "Session alive at $(Get-Date -Format 'HH:mm:ss')..."
            
            $nodeProcs = Get-Process -Name "node" -ErrorAction SilentlyContinue
            if (-not $nodeProcs) {
              Write-Host "OpenClaw not running, restarting..."
              $env:PATH = "$rdpUserHome\.npm-global;$env:PATH"
              Start-Process -WindowStyle Hidden -FilePath "node" -ArgumentList "$rdpUserHome\.npm-global\node_modules\openclaw\openclaw.mjs", "gateway" -WorkingDirectory "$rdpUserHome\.openclaw"
              Write-Host "OpenClaw restarted"
            }
            
            Start-Sleep -Seconds 300
          }
